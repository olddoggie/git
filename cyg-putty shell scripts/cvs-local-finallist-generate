#!/usr/bin/bash
# This script processes command line by line, mainly to combine all the file list together and eliminates duplicates lines.
echo "Rational is using read Line and then do command based on each line output, pay attention to the double qoute on variables and IFS.."
echo "first param is ito cvs module (cs/af/fs750/fs/services...)"
echo "second param is the target CAT release file folder you want to process on,(e.g./cygdrive/d/release/cs/file/CS7.81-CAT1)"
echo "*Pay attention that after final list generated, is there still existing any duplicate added/modified/deleted/SYNC file lines."
echo "**Pay attention to the situation that result list has contained the files out of our scope, should grep -v to delete them."
echo "After generation,double check: compare the final list with the filelist generated by CVS."
echo ""
module=$1
target_folder="$2"
dir=~/final-file-list
temp=temp.txt
copy=temp-copy.txt
input=temp-input.txt
result_folder=~/final-file-list/result
read -p "How many deployments did you make for this CAT: " deploy_num
echo ""

function initial ()
{
if [ -d $dir ]
  then
	rm -rf $dir
fi
echo "Creating directory final-file-list..."
mkdir $dir
mkdir $result_folder
source ~/bin/go $dir
echo "Initializing finished..."
echo ""
}

function check_sum ()
{
echo "Checking whether the files_num equals to build/deploy num '$deploy_num'..."
echo ""
files_num=`cat $copy | wc -l`
if [ ! $files_num -eq $deploy_num ]
  then
	echo "Incorrect file numbers,please check the '$target_folder' and do it again..."
	exit 1
fi
echo "Check finished,number is correct:'$deploy_num'!"
echo ""
}

function cp-file ()
{
echo "Copying all '$2' txt files from '$1' to '$dir'..."
find  $1 | sort -t '-' -k4 | grep txt | grep $2 > $copy
declare -i i=0;while read LINE;do i=i+1;cp "$LINE" $2$i.txt; done < $copy
echo "Copy finished..."
echo ""
check_sum
echo ""
}

function grep-v ()
{
while read LINE
do
cat $temp | grep -v "$LINE" > $temp
done < $input
}

function grep-v-am ()
{
while read LINE
do
cat $temp | grep -v "A    $LINE" | grep "M    $LINE" | sed 's/M    /A    /g' >> $temp
cat $temp | grep -v "M    $LINE" | grep -v "A    $LINE \"added" > $temp
done < $input
}

function grep-v-md ()
{
while read LINE
do
cat $temp | grep -v "M    $LINE" > $temp
done < $input
}

function grep-v-ad ()
{
while read LINE
do
cat $temp | grep -v "A    $LINE" | grep -v "D    $LINE" > $temp
done < $input
}

function combine-file ()
{
# $1,$2 is origine file copied from $target_dir; $3 and $4 is temp files corresponding to $1,$2.
# $input and $temp are connective files with command grep-v
# the only output file is $5
cat $1 | awk '/^[A-Za-z0-9]/ {print $0}' | sort -u  > $1 | cut -d '"' -f1 $1 > $3
cat $2 | awk '/^[A-Za-z0-9]/ {print $0}' | sort -u  > $2 | cut -d '"' -f1 $2 > $4
comm -12 $3 $4 > $input
cp -f $1 $temp
grep-v
cp -f $2 $5 && cat $temp >> $5 && cat $5 | sort -u > $5
echo "Result has been generated into '$5'..."
echo ""
}

function final-list-gen ()
{
sk=y
while [ "$sk" == "y" -o "$sk" == "Y"  ] 
do
echo ""
read -p "Do you need combine all file list to make a final one for '$1' CAT release? input n to Skip/input y to do it...................... " sk
echo ""
if [ "$sk" = "n" -o "$sk" = "N" ]
 then
	echo "Skip."
fi
if [ "$sk" = "y" -o "$sk" = "Y" ]
 then
	echo "Now you are going to combine all file list to make a final one for this CAT..."
	cp-file  "$target_folder" $1
	echo "Start combining file lists for '$target_folder's '$1' module..."
	echo ""
	declare -i sum=`ls "$1"*.txt |wc -l`
	if [ $sum -eq 1 ]
	 then
		cat "$1"1.txt | awk '/^[A-Za-z0-9]/ {print $0}' | sort -u  | tee $2
		echo "====== file list '$1' file num is ========"
		cat $2 | wc -l
		echo ""
	else
		echo "Comparing first with second list ordered by build time..."
		echo ""
		combine-file "$1"1.txt "$1"2.txt temp-1.txt temp-2.txt $2
			if [ $sum -eq 2 ]
			 then
				echo ""
				echo "====== file list '$1' file num is ========"
				cat $2 | wc -l
				echo ""
			else
				echo ""
				echo "First comparision finished, now let's move on...."
				declare -i j=3
				while [ $j -le $sum ]
				do
				combine-file $2 "$1"$j.txt temp-result.txt temp-$j.txt $2
				j=j+1
				done
				echo "====== file list '$1' file num is ========"
				cat $2 | wc -l
				echo ""
			fi
	fi
break
else
	read -p "Confirm whether you really wanna combine all file list to make a final one for '$1' CAT release? input n to Skip/input y or blank to do it again...................... " sk
	if [ "$sk" = "n" -o "$sk" = "N" ]
	 then
		echo "Skip."
	else
		sk=y # continue loop.
	fi
fi
done	
}

function eliminate-duplicate-amd ()
{
sk=y
while [ "$sk" == "y" -o "$sk" == "Y"  ] 
do
echo ""
read -p "Do you need elimintate potential duplicate lines for '$1' in added/modified/deleted? input n to Skip/input y to do it...................... " sk
echo ""
if [ "$sk" = "n" -o "$sk" = "N" ]
 then
	echo "Skip."
fi
if [ "$sk" = "y" -o "$sk" = "Y" ]
 then
	echo "Now you are going to elimainate duplicate lines for '$1' in added/modified/deleted..."
	echo ""
	cp -f $1 $temp
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	echo "1.Added line should be removed and Modifyied line should be kept,while the first char should be A..."
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"	
	echo ""
	source ~/bin/cvs-local-filelist-compare ram
	input=common-part-AM.txt
	grep-v-am
	echo "OK!"
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"	
	echo "2.Modified line should be removed and Deleted line should be kept..."
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"	
	echo ""
	source ~/bin/cvs-local-filelist-compare rmd
	input=common-part-MD.txt
	grep-v-md
	echo "OK!!"
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"	
	echo "3.Added line should be removed and Deleted line also should be removed..."
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"	
	echo ""
	source ~/bin/cvs-local-filelist-compare rad
	input=common-part-AD.txt
	grep-v-ad
	echo "OK!!!"
	cat $temp | sort -u | tee $1
	echo "====== final file list '$1' num is ========"
	cat $1 | wc -l
	echo ""
break
else
	read -p "Confirm whether you really wanna elimintate potential duplicate lines for '$1' in added/modified/deleted? input n to Skip/input y or blank to do it again...................... " sk
	if [ "$sk" = "n" -o "$sk" = "N" ]
	 then
		echo "Skip."
	else
		sk=y # continue loop.
	fi
fi
done
}

function eliminate-duplicate-sync ()
{
sk=y
while [ "$sk" == "y" -o "$sk" == "Y"  ] 
do
echo ""
read -p "Do you need elimintate potential duplicate SYNC lines for '$1'? input n to Skip/input y to do it...................... " sk
echo ""
if [ "$sk" = "n" -o "$sk" = "N" ]
 then
	echo "Skip."
fi
if [ "$sk" = "y" -o "$sk" = "Y" ]
 then
	echo "Now you are going to elimainate duplicate lines SYNC lines for '$1' between final list and sync list..."
	echo ""
	cp -f $1 $temp
	file0=sync-list.txt
	dir0=sync
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	echo "Duplicated line in sync list for '$1' should be removed..."
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	echo ""
	echo "Starting to generate total sync list for '$1' ..."
	echo ""
	if [ -f $file0 ]
  	 then
		rm -f $file0
	fi
	echo ""
	read -p "please prepare all the SYNC files into '$file0'...Press Enter"
	read -p "..................................................Press Enter"
	read -p "finsh fill in the all SYNC codes into '$file0'?...Press Enter"
	echo "Ok."	
	
	
	
	
	source ~/bin/cvs-local-filelist-compare r
	input=common-part-sync.txt
	cp -f temp-sync-list.txt $temp
	grep-v
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	echo "OK!!!! The total file(with sync) list result will be generated into 'plus-sync-$1'..."
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	echo ""
	cat $temp >> $1 && cat $1 | sort -u > plus-sync-"$1"
	echo "====== total file list '$1' num is ========"
	cat plus-sync-"$1" | wc -l
	echo ""
break
else
	read -p "Confirm whether you really wanna elimintate potential duplicate SYNC lines for '$1'? input n to Skip/input y or blank to do it again...................... " sk
	if [ "$sk" = "n" -o "$sk" = "N" ]
	 then
		echo "Skip."
	else
		sk=y # continue loop.
	fi
fi
done
}

function announce-finish ()
{
echo "Now you are gonna double check the total file list(with sync) for module '$1'..."
echo ""
echo "Combine different result(with sync) list module by module..."
echo ""
rm $temp
cat plus-sync-result-*.txt >>  $temp
echo ""
read -p "Do you need double check the accuracy by diffing result(with sync) list with the CVS final update filelist? input n to Skip...................... " sk
echo ""
if [ "$sk" = "n" -o "$sk" = "N" ]
 then
	echo "Skip."
else
	echo "Start generate CVS final update filelist ..."
	echo ""
	echo "======================================================================"
	read -p "Module Name,e.g.cs/af/fs750/fs/services: " mn
	read -p "Previous CAT tag,e.g.BLEUM_FS_CAT3_12262012_1: " ptg
	read -p "Current CAT head/branch/tag,e.g.HEAD/FS_7_50: " ctg
	read -p "Input finish..Module is '$mn',Pre-tag is '$ptg',Current tag is '$ctg'..Press Enter"
	read -p "If any input typo, don't worry, mannually do source ~/bin/cvs-local-check-update to get the CVS final list..Press Enter"
	echo "======================================================================"
	source ~/bin/cvs-local-check-update $mn $ptg $ctg
	echo ""
	echo "Start final check..."	
	echo ""
	source ~/bin/cvs-local-filelist-compare f
	echo ""
	output=compare-result-filelist.txt
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"	
	echo "Finished final check, pay attention to the difference part listed in '$output'..."
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	cp $output $result_folder
	echo ""
fi
cat $temp | sort -u > plus-sync-result-"$1".txt
echo "====== total file(with sync) list for module '$1' num is ========"
cat plus-sync-result-"$1".txt | wc -l
cp plus-sync-result-"$1".txt $result_folder
echo ""
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "Pay attention to the situation that result list has contained the files out of our scope, should grep -v to delete them!"
echo ""
echo "This situation mught happen once we sync codes from 1FB HEAD trunk --> we merge synced codes to our branch --> finally check them into ito branch, instead of 1FB team help merging their HEAD trunk codes into ito branch --> we sync back the branch codes."
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo ""
read -p "Are you 100% sure that no Out-Of-Scope files existing in result list? Or you'll have to use grep -v to ignore those files....Press Enter"
echo ""
echo "Good job! Final update file list done. Check detail in '$result_folder/result-*.txt' kept them in CM log."
cp result-*.txt $result_folder
echo ""
echo "Still, Don't forget to compare the code between two CVS after baselined Release Tag and send out any additional configuration related tips for this CAT release to Customer!"
}

case $module in
  "cs")
		initial
		for target_module in cs-src cs-war
		do
			result=result-"$target_module".txt
			final-list-gen $target_module $result
		done
		for result in result-cs-src.txt result-cs-war.txt
		do
			eliminate-duplicate-amd $result
		done
		for result in result-cs-src.txt result-cs-war.txt
		do
			eliminate-duplicate-sync $result
		done
		announce-finish cs
		;;
  "af")
		initial
		for target_module in afcollagent-src afcollagent-war afcsragent-src afcsragent-war afshared-src afshared-war
		do
			result=result-"$target_module".txt
			final-list-gen $target_module $result
		done
		for result in result-afcollagent-src.txt result-afcollagent-war.txt result-afcsragent-src.txt result-afcsragent-war.txt result-afshared-src.txt result-afshared-war.txt
		do
			eliminate-duplicate-amd $result
		done
		for result in result-afcollagent-src.txt result-afcollagent-war.txt result-afcsragent-src.txt result-afcsragent-war.txt result-afshared-src.txt result-afshared-war.txt
		do
			eliminate-duplicate-sync $result
		done
		announce-finish affinity
		;;
  "fs750")
		initial
		for target_module in fscm-src fscm-war fsshared-src fssplashcontent-src fssplashcontent-war services-src services-mapping
		do
			result=result-"$target_module".txt
			final-list-gen $target_module $result
		done
		for result in result-fscm-src.txt result-fscm-war.txt result-fsshared-src.txt result-fssplashcontent-src.txt result-fssplashcontent-war.txt result-services-src.txt result-services-mapping.txt
		do
			eliminate-duplicate-amd $result
		done
		for result in result-fscm-src.txt result-fscm-war.txt result-fsshared-src.txt result-fssplashcontent-src.txt result-fssplashcontent-war.txt result-services-src.txt result-services-mapping.txt
		do
			eliminate-duplicate-sync $result
		done
		announce-finish fs750
		;;
  "fs")
		initial
		for target_module in fsagent-src fsagent-war fscm-src fscm-war fsshared-src
		do
			result=result-"$target_module".txt
			final-list-gen $target_module $result
		done
		for result in result-fsagent-src.txt result-fsagent-war.txt result-fscm-src.txt result-fscm-war.txt result-fsshared-src.txt
		do
			eliminate-duplicate-amd $result
		done
		for result in result-fsagent-src.txt result-fsagent-war.txt result-fscm-src.txt result-fscm-war.txt result-fsshared-src.txt
		do
			eliminate-duplicate-sync $result
		done
		announce-finish fs
		;;
  "services")
		initial
		for target_module in services-src services-mapping
		do
			result=result-"$target_module".txt
			final-list-gen $target_module $result
		done
		for result in result-services-src.txt result-services-mapping.txt
		do
			eliminate-duplicate-amd $result
		done
		for result in result-services-src.txt result-services-mapping.txt
		do
			eliminate-duplicate-sync $result
		done
		announce-finish services
		;;		
		*)
		echo "no such module yet..."
		exit 1
		;;
esac