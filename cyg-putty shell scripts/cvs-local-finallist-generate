#!/usr/bin/bash
# This script processes command line by line, mainly to combine all the file list together and eliminates duplicates lines.
echo "Rational is using read Line and then do command based on each line output, pay attention to the double qoute on variables and IFS.."
echo "first param is ito cvs module (cs/af/fs750/fs/services...)"
echo ""
echo "second param is the target CAT release file folder you want to process on,(e.g./cygdrive/d/release/cs/file/CS7.81-CAT1)"
echo ""
echo "*Pay attention that after final list generated, is there still existing any duplicate added/modified/deleted/SYNC file lines."
echo ""
echo "**Pay attention that the generated total sync list in eliminate-duplicate-sync step may not be 100% correct,'cause there might be tiny possibility that SYA and SYD are duplicated."
echo ""
echo "***Pay attention to the situation that result list has contained the files out of our scope, should grep -v to delete them."
echo ""
echo "After generation,double check: compare the final list with the filelist generated by CVS."
echo ""
module=$1
target_folder="$2"
dir=~/final-file-list
temp=temp.txt
copy=temp-copy.txt
input=temp-input.txt
result_folder=$dir/result
sync_folder=$dir/sync
sync_file=sync-list.txt
bleumcvsroot=":sspi:jack.wang@192.168.2.200:/1fb"

read -p "How many deployments did you make for this CAT: " deploy_num
echo ""
read -p "Input 'HEAD' or <Branch_Name> for this CAT: " deploy_tag
echo ""

if [ "$deploy_tag" != "HEAD" -a "$deploy_tag" != "head" ]
  then
 	echo "This CAT is released on branch '$deploy_tag'!"
	echo ""
	branch_name="$deploy_tag."
else
	echo "This CAT is released on HEAD trunk!"
	echo ""
	branch_name=HEAD
fi

function initial ()
{
if [ -d $dir ]
  then
	rm -rf $dir
fi
echo "Creating directory final-file-list..."
mkdir $dir
mkdir $result_folder
source ~/bin/go $dir
echo "Initializing finished..."
echo ""
}

function check_sum ()
{
echo "Checking whether the files_num equals to build/deploy num '$deploy_num'..."
echo ""
files_num=`cat $copy | wc -l`
if [ ! $files_num -eq $deploy_num ]
  then
	echo "Incorrect file numbers,please check the '$target_folder' and do it again..."
	exit 1
fi
echo "Check finished,number is correct:'$deploy_num'!"
echo ""
}

function cp-file ()
{
echo "Copying all '$2' txt files from '$1' to '$dir'..."
find  "$1" | sort -t '-' -k4 | grep txt | grep "$2" > $copy
declare -i i=0;while read LINE;do i=i+1;cp -f "$LINE" "temp-$2"$i.txt; done < $copy
echo "Copy finished..."
echo ""
check_sum
echo ""
}

function fetch-cvspath ()
{
echo "According to '$1',now recover the whole path in CVS repo..."
echo ""
target1=`echo "$1" | awk -F '-' '{print $1}'`
target2=`echo "$1" | awk -F '-' '{print $2}'`
case $module in
	"cs")
	 target_cvspath="csmaintenance/3.50/SourceCodeUBS/$target2"
	 ;;
	 "af")
	 target_cvspath="affinity/sourcecode/$target1/$target2"
	 ;;
	 "af360")
		case $target1 in
		fsshared)	
				target_cvspath="fs/Sourcecode/$target1/$target2"
				branch_name="AFF_3_60_CAT1."				
				;;
		services)	
				target_cvspath="$target1/Sourcecode/$target2"
				branch_name="AFF_3_60_CAT1."
				;;
			*)
				target_cvspath="affinity/sourcecode/$target1/$target2"
				;;
		esac
	 ;;
	 "fs")
	 target_cvspath="fs/Sourcecode/$target1/$target2"
	 ;;
	 "fs750")
		case $target1 in
			services)	
				target_cvspath="$target1/Sourcecode/$target2"
				;;
			*)
				target_cvspath="fs/Sourcecode/$target1/$target2"
				;;
		esac
	 ;;
	 "services")
	 target_cvspath="$target1/Sourcecode/$target2"
	 ;;
esac
echo "Whole path in CVS repo is '$target_cvspath'..."
echo ""
}

function fetch-cvslog ()
{
echo "Getting cvs.log from '$deploy_tag' of module '$1'..."
echo ""
fetch-cvspath "$1"
cvs_log=cvs.log_"$1"
cvs -d $bleumcvsroot rlog -N -r"$branch_name" "$target_cvspath" > "$cvs_log"
echo "cvs.log has been generated as 'cvs.log_$1'..."
echo ""
}

function grep-v-am ()
{
while read LINE
do
cat $temp | grep -v "A    $LINE" | grep "M    $LINE" | sed 's/M    /A    /g' >> $temp
cat $temp | grep -v "M    $LINE" | grep -v "A    $LINE \"added" > $temp
done < $input
}

function grep-v-md ()
{
while read LINE
do
cat $temp | grep -v "M    $LINE" > $temp
done < $input
}

function grep-v-ad ()
{
while read LINE
do
cat $temp | grep -v "A    $LINE" | grep -v "D    $LINE" > $temp
done < $input
}

function combine-file ()
{
# $1.txt is combination of origine files($1*.txt) copied from $target_dir
# the output file $2($1.txt) is the refined verison of combined filelist which has no coments appended 
cat "temp-$1"*.txt | awk '/^[A-Za-z]/ {print $0}' | cut -d '"' -f1 | sort -u > "$2"
echo "Comments eliminated from combined file list into '$2'... "
echo ""
}

function combine-sync-file ()
{
cat temp-sync-*.txt | awk '/^[A-Za-z]/ {print $0}' | cut -d '"' -f1 | awk '{ {for(j = 2; j<NF; j++) printf "%s ",$j} printf "%s\n",$j}' \
| sort -u   > "$1"
echo "SYNC files combined into '$1'... "
echo ""
}

function final-list-gen ()
{
sk=y
while [ "$sk" == "y" -o "$sk" == "Y"  ] 
do
echo ""
read -p "Do you need combine all file list to make a final one for '$1' CAT release? input n to Skip/input y to do it...................... " sk
echo ""
if [ "$sk" = "n" -o "$sk" = "N" ]
 then
	echo "Skip."
	break
fi
if [ "$sk" = "y" -o "$sk" = "Y" ]
 then
	echo "Now you are going to combine all file list to make a final one for this CAT..."
	cp-file  "$target_folder" "$1"
	echo ""
	fetch-cvslog "$1"
	echo "Start combining file lists for '$target_folder's '$1' module..."
	echo ""
	combine-file "$1" "$1".txt
	# declare -i sum=`ls "$1"*.txt |wc -l`
	# if [ $sum -eq 1 ]
	 # then
		# cat "$1"1.txt | awk '/^[A-Za-z0-9]/ {print $0}' | sort -u  | tee $2
		# echo "====== file list '$1' file num is ========"
		# cat $2 | wc -l
		# echo ""
	# else
		# echo "Comparing first with second list ordered by build time..."
		# echo ""
		# combine-file "$1"1.txt "$1"2.txt temp-1.txt temp-2.txt $2
			# if [ $sum -eq 2 ]
			 # then
				# echo ""
				# echo "====== file list '$1' file num is ========"
				# cat $2 | wc -l
				# echo ""
			# else
				# echo ""
				# echo "First comparision finished, now let's move on...."
				# declare -i j=3
				# while [ $j -le $sum ]
				# do
				# combine-file $2 "$1"$j.txt temp-result.txt temp-$j.txt $2
				# j=j+1
				# done
				# echo "====== file list '$1' file num is ========"
				# cat $2 | wc -l
				# echo ""
			# fi
	# fi
	echo "Now starting generate file list '$2'..."
	if [ `cat "$1".txt | wc -l` -eq 0 ]
	 then
		echo "No code update in module: '$1', just Skip to generate '$2'..."
		cp -f "$1".txt "$2"
	else
	cat "$1".txt | awk '{ {for(j = 2; j<NF; j++) printf "%s ",$j} printf "%s\n",$j}' \
	| awk -F '/' '{ {for(j = 1; j<NF; j++) printf "%s\\\\/",$j} printf "%s\n",$j}' > $input
	# need use \\\\ in awk because $input should be like:com\\/onefbusa\\/afcollagent\\/web\\/action\\/search\\/COLLSearchAction.java
	# so that when read Line below, the Line can be read as com\/onefbusa\/afcollagent\/web\/action\/search\/COLLSearchAction.java
	# so that the sed can recongnize it as com/onefbusa/afcollagent/web/action/search/COLLSearchAction.java
	# fyi, eliminate \n, can use tr "\n" " " , also can use sed -e :a -e '$!N; s/\n/ /; ta' to replace \n, same as tr "\n" " "
	while read LINE
	do
	cat "$cvs_log" | awk '/'"$LINE"'/,/=====/ {print $0}'| sed -e '/'"$LINE"'/,/^date:/d' -e '$d' \
	| tr \" \'| awk '{printf "\"%s \"\n",$0}'
	done < $input | paste -d " " "$1".txt - > "$2"
	cat "$2" | sed '/^A/ s/  "/ "added by Bleum: /g; /^M/ s/  "/ "modified by Bleum: /g; /^D/ s/  "/ "deleted by Bleum: /g' > "$2"
	echo ""
	echo "====== file list '$2' generated initially, file num is ========"
	cat "$2" | wc -l
	fi
	echo ""	
break
else
	read -p "Confirm whether you really wanna combine all file list to make a final one for '$1' CAT release? input n to Skip/input y or blank to do it again...................... " sk
	if [ "$sk" = "n" -o "$sk" = "N" ]
	 then
		echo "Skip."
	else
		sk=y # continue loop.
	fi
fi
done
}

function eliminate-duplicate-amd ()
{
sk=y
while [ "$sk" == "y" -o "$sk" == "Y"  ] 
do
echo ""
read -p "Do you need elimintate potential duplicate lines for '$1' in added/modified/deleted? input n to Skip/input y to do it...................... " sk
echo ""
if [ "$sk" = "n" -o "$sk" = "N" ]
 then
	echo "Skip."
	break
fi
if [ "$sk" = "y" -o "$sk" = "Y" ]
 then
	echo "Now you are going to elimainate duplicate lines for '$1' in added/modified/deleted..."
	echo ""
	cp -f "$1" $temp
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	echo "1.Added line should be removed and Modifyied line should be kept,while the first char should be A..."
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"	
	echo ""
	source ~/bin/cvs-local-filelist-compare ram
	input=common-part-AM.txt
	grep-v-am
	echo "OK!"
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"	
	echo "2.Modified line should be removed and Deleted line should be kept..."
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"	
	echo ""
	source ~/bin/cvs-local-filelist-compare rmd
	input=common-part-MD.txt
	grep-v-md
	echo "OK!!"
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"	
	echo "3.Added line should be removed and Deleted line also should be removed..."
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"	
	echo ""
	source ~/bin/cvs-local-filelist-compare rad
	input=common-part-AD.txt
	grep-v-ad
	echo "OK!!!"
	cat $temp | sort -u | tee "$1"
	echo "====== final file list '$1' num is ========"
	cat $1 | wc -l
	echo "Updating '$target_module.txt'..."
	cat "$1" | cut -d '"' -f1 > "$target_module".txt
	echo "OK!!"
	echo ""
break
else
	read -p "Confirm whether you really wanna elimintate potential duplicate lines for '$1' in added/modified/deleted? input n to Skip/input y or blank to do it again...................... " sk
	if [ "$sk" = "n" -o "$sk" = "N" ]
	 then
		echo "Skip."
	else
		sk=y # continue loop.
	fi
fi
done
}

function eliminate-duplicate-sync ()
{
sk=y
while [ "$sk" == "y" -o "$sk" == "Y"  ] 
do
echo ""
read -p "Optional.Do you need elimintate potential duplicate SYNC lines for '$target_module'? input n to Skip/input y to do it...................... " sk
echo ""
if [ "$sk" = "n" -o "$sk" = "N" ]
 then
	echo "Skip."
	cat "$1" | awk '{ {for(j = 2; j<NF; j++) printf "%s ",$j} printf "%s\n",$j}' | sort -u | awk '{print "PSY  "$0}' > plus-sync-"$1"
	echo "====== total file list plus-sync-'$1' num is ========"
	cat plus-sync-"$1" | wc -l
	break
fi
if [ "$sk" = "y" -o "$sk" = "Y" ]
 then
 	cp -f "$1" final-list.txt
	echo "Now you are going to elimainate duplicated SYNC lines for '$target_module' between final list and sync list..."
	echo ""
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	echo "Duplicated lines in sync list for '$target_module' should be removed..."
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	echo ""
	echo "Initializing '$sync_folder'..."
	if [ -d $sync_folder ]
  	 then
		rm -rf $sync_folder
	fi
	mkdir $sync_folder
	source ~/bin/go $sync_folder
	declare -i s=1
	while [ $s -le 10 ] 
	do	
	touch temp-sync-$s.txt
	s=s+1
	done
	echo ""
	echo "======================================================================"
	read -p "please prepare all the SYNC files into '$sync_folder', naming as sync-1.txt,sync-2.txt ordered by time for '$target_module' module only!...Press Enter"
	read -p "waiting..................................................Press Enter"
	read -p "finish fill in the all SYNC files into '$sync_folder'?...Press Enter"
	echo "======================================================================"
	echo "Ok."	
	echo "Starting to generate total sync list for '$target_module' into '$dir/$sync_file'..."
	echo ""
	echo "Comparing sync list ascendingly..."
	echo ""
	combine-sync-file $sync_file
	# declare -i sum=`ls *.txt |wc -l`
	# if [ $sum -eq 1 ]
	 # then
	 	# echo "Result has been generated into '$sync_file'..."
		# echo ""
		# cp -f 1.txt $sync_file
	# else
		# combine-sync-file 1.txt 2.txt temp-1.txt temp-2.txt $sync_file
		# if [ ! $sum -eq 2 ]
		 # then
			# echo "First comparision finished, now let's move on...."
			# echo ""
			# declare -i j=3
			# while [ $j -le $sum ]
			# do
			# combine-sync-file $sync_file $j.txt temp-$sync_file temp-$j.txt $sync_file
			# j=j+1
			# done
		# fi
	# fi
	echo "Finish comparing sync list for '$target_module'..."
	echo ""
	echo "====== SYNC list '$sync_file' num is ========"
	cat $sync_file | wc -l
	echo ""
	source ~/bin/go $dir
	cat $sync_folder/$sync_file | awk '{print "SY   "$0}' > $sync_file && cp $sync_file $result_folder/sync-"$1"
	echo "Now,the total sync list has been generated into '$dir/$sync_file', also make a back-up as '$result_folder/sync-$1'..."
	echo ""
	echo "Comparing two ruby file: 1.<final-list.txt> --->file list:'$1', 2.<$sync_file> --->sync list:'sync-$1'..."
	echo ""
	source ~/bin/cvs-local-filelist-compare r
	echo "Pay attention to the files listed in 'common-part-ruby.txt', they should be Eliminated from '$sync_file', and Make sure they are not duplicated anymore in 'plus-sync-$1' after combined <final-list.txt> and <$sync_file>..."
	cat final-list.txt $sync_file | awk '{ {for(j = 2; j<NF; j++) printf "%s ",$j} printf "%s\n",$j}' | sort -u \
	| awk '{print "PSY  "$0}' > plus-sync-"$1"
	echo ""
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	echo "OK!!!! The total file(with sync) list result is generated into 'plus-sync-$1'..."
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	echo ""
	echo "====== total file list plus-sync-'$1' num is ========"
	cat plus-sync-"$1" | wc -l
	echo ""
break
else
	read -p "Confirm whether you really wanna elimintate potential duplicate SYNC lines for '$target_module'? input n to Skip/input y or blank to do it again...................... " sk
	if [ "$sk" = "n" -o "$sk" = "N" ]
	 then
		echo "Skip."
		cat "$1" | awk '{ {for(j = 2; j<NF; j++) printf "%s ",$j} printf "%s\n",$j}' | sort -u | awk '{print "PSY  "$0}' > plus-sync-"$1"
		echo "====== total file list plus-sync-'$1' num is ========"
		cat plus-sync-"$1" | wc -l		
	else
		sk=y # continue loop.
	fi
fi
done
}

function announce-finish ()
{
echo "Now you are gonna double check the total file list(with sync) for module '$1'..."
echo ""
echo "Combine different result(with sync) list module by module..."
echo ""
rm $temp
cat plus-sync-*.txt >>  $temp
echo ""
read -p "Optional.Do you need double check the accuracy by diffing result(with sync) list with the CVS final update filelist? input n to Skip...................... " sk
echo ""
if [ "$sk" = "n" -o "$sk" = "N" ]
 then
	echo "Skip."
else
	echo "Start generate CVS final update filelist ..."
	echo ""
	echo "======================================================================"
	read -p "Module Name,e.g.cs/af/fs750/fs/services: " mn
	read -p "Previous CAT tag,e.g.BLEUM_FS_CAT3_12262012_1: " ptg
	read -p "Current CAT head/branch/tag,e.g.HEAD/FS_7_50: " ctg
	read -p "Input finish..Module is '$mn',Pre-tag is '$ptg',Current tag is '$ctg'..Press Enter"
	read -p "If any input typo, don't worry, mannually do source ~/bin/cvs-local-check-update to get the CVS final list..Press Enter"
	echo "======================================================================"
	source ~/bin/cvs-local-check-update $mn $ptg $ctg
	echo ""
	echo "Start final check..."	
	echo ""
	source ~/bin/cvs-local-filelist-compare f
	echo ""
	output=compare-result-filelist.txt
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"	
	echo "Finished final check, pay attention to the difference part listed in '$output'..."
	echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	cp $output $result_folder
	echo ""
fi
cat $temp > plus-sync-"$1".txt
echo "====== total file(All '$1' modules with sync) list: plus-sync-"$1".txt num is ========"
cat plus-sync-"$1".txt | wc -l
cp plus-sync-"$1".txt $result_folder
echo ""
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "Pay attention to the situation that result list has contained the files out of our scope, should grep -v to delete them!"
echo ""
echo "This situation mught happen once we sync codes from 1FB HEAD trunk --> we merge synced codes to our branch --> finally check them into ito branch, instead of 1FB team help merging their HEAD trunk codes into ito branch --> we sync back the branch codes."
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo ""
read -p "Are you 100% sure that no Out-Of-Scope files existing in result list? Or you'll have to use grep -v to ignore those files....Press Enter"
echo ""
read -p "Just FYI,as above mentioned,the generated total sync list in eliminate-duplicate-sync step may not be 100% correct,'cause there might be tiny possibility that SYA and SYD are duplicated....Press Enter" -t 5
echo ""
echo "cvs log files for each tartget_module have been copied to '$result_folder/cvs.log_*', take reference if needed."
cp cvs.log_* $result_folder
echo ""
echo "Good job! Final update file list done. Check detail in '$result_folder/result-*.txt' kept them in CM log."
cp result-*.txt $result_folder
echo ""
echo "Still, Don't forget to compare the code between two CVS after baselined Release Tag and send out any additional configuration related tips for this CAT release to Customer!"
}

case $module in
  "cs")
		initial
		for target_module in cs-src cs-war
		do
			result=result-"$target_module".txt
			final-list-gen $target_module $result
		done
		for result in result-cs-src.txt result-cs-war.txt
		do
			eliminate-duplicate-amd $result
		done
		for target_module in cs-src cs-war
		do
			eliminate-duplicate-sync "$target_module".txt
		done
		announce-finish cs
		;;
  "af")
		initial
		for target_module in afcollagent-src afcollagent-war afcsragent-src afcsragent-war afshared-src afshared-war
		do
			result=result-"$target_module".txt
			final-list-gen $target_module $result
		done
		for result in result-afcollagent-src.txt result-afcollagent-war.txt result-afcsragent-src.txt result-afcsragent-war.txt result-afshared-src.txt result-afshared-war.txt
		do
			eliminate-duplicate-amd $result
		done
		for target_module in afcollagent-src afcollagent-war afcsragent-src afcsragent-war afshared-src afshared-war
		do
			eliminate-duplicate-sync "$target_module".txt
		done
		announce-finish affinity
		;;
  "af360")
		initial
		for target_module in afcollagent-src afcollagent-war afcsragent-src afcsragent-war afshared-src afshared-war fsshared-src services-src services-mapping
		do
			result=result-"$target_module".txt
			final-list-gen $target_module $result
		done
		for result in result-afcollagent-src.txt result-afcollagent-war.txt result-afcsragent-src.txt result-afcsragent-war.txt result-afshared-src.txt result-afshared-war.txt result-fsshared-src.txt result-services-src.txt result-services-mapping.txt
		do
			eliminate-duplicate-amd $result
		done
		for target_module in afcollagent-src afcollagent-war afcsragent-src afcsragent-war afshared-src afshared-war fsshared-src services-src services-mapping
		do
			eliminate-duplicate-sync "$target_module".txt
		done
		announce-finish af360
		;;		
  "fs750")
		initial
		for target_module in fscm-src fscm-war fsshared-src fssplashcontent-src fssplashcontent-war services-src services-mapping
		do
			result=result-"$target_module".txt
			final-list-gen $target_module $result
		done
		for result in result-fscm-src.txt result-fscm-war.txt result-fsshared-src.txt result-fssplashcontent-src.txt result-fssplashcontent-war.txt result-services-src.txt result-services-mapping.txt
		do
			eliminate-duplicate-amd $result
		done
		for target_module in fscm-src fscm-war fsshared-src fssplashcontent-src fssplashcontent-war services-src services-mapping
		do
			eliminate-duplicate-sync "$target_module".txt
		done
		announce-finish fs750
		;;
  "fs")
		initial
		for target_module in fsagent-src fsagent-war fscm-src fscm-war fsshared-src
		do
			result=result-"$target_module".txt
			final-list-gen $target_module $result
		done
		for result in result-fsagent-src.txt result-fsagent-war.txt result-fscm-src.txt result-fscm-war.txt result-fsshared-src.txt
		do
			eliminate-duplicate-amd $result
		done
		for target_module in fsagent-src fsagent-war fscm-src fscm-war fsshared-src
		do
			eliminate-duplicate-sync "$target_module".txt
		done
		announce-finish fs
		;;
  "services")
		initial
		for target_module in services-src services-mapping
		do
			result=result-"$target_module".txt
			final-list-gen $target_module $result
		done
		for result in result-services-src.txt result-services-mapping.txt
		do
			eliminate-duplicate-amd $result
		done
		for target_module in services-src services-mapping
		do
			eliminate-duplicate-sync "$target_module".txt
		done
		announce-finish services
		;;		
		*)
		echo "no such module yet..."
		exit 1
		;;
esac